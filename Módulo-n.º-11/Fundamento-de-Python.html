<!DOCTYPE html>
<html lang="pt_BR">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>7. Entrada e Saída — documentação Python 3.11.3</title>
    <link rel="icon" type="image/x-icon" href="./img/Logo.png"/>
  </head>

<body>

  <img src="./img/EPF.png" height="200" width="400">
  <body topmargin=50 leftmargin=200 rightmargin="200"></body>

  <style>
    body {
        padding: 25px;
        background-color: white;
        color: rgb(255, 255, 255);
        font-size: 25px;
    }
    .dark-mode {
        background-color: black;
        color: rgb(255, 0, 0);
    }
    .light-mode {
        background-color: white;
        color: rgb(255, 255, 255);
    }
</style>

</head>
    <button onclick="darkMode()">RedMode</button>
    <button onclick="lightMode()">LightMode</button>
    <script>
    function darkMode() {
        var element = document.body;
        var content = document.getElementById("DarkModetext");
        element.className = "dark-mode";
        content.innerText = "Dark Mode is ON";
    }
    function lightMode() {
        var element = document.body;
        var content = document.getElementById("DarkModetext");
        element.className = "light-mode";
        content.innerText = "Dark Mode is OFF";
    }
</script>
            
  <section id="input-and-output">
<span id="tut-io"></span><h1><span class="section-number">7. </span>Entrada e Saída</h1>
<p>Existem várias maneiras de apresentar a saída de um programa; os dados podem ser exibidos em forma legível para seres humanos, ou escritos em arquivos para uso posterior. Este capítulo apresentará algumas das possibilidades.</p>
<section id="fancier-output-formatting">
<span id="tut-formatting"></span><h2><span class="section-number">7.1. </span>Refinando a formatação de saída</h2>
<p>Até agora vimos duas maneiras de exibir valores: <em>expressões</em> e a função print(). (Uma outra maneira é utilizar o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> de objetos do tipo arquivo; o arquivo saída padrão pode ser referenciado como <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>. Veja a Referência da Biblioteca Python para mais informações sobre isso.)</p>
<p>Muitas vezes se deseja mais controle sobre a formatação da saída do que simplesmente exibir valores separados por espaço. Existem várias maneiras de formatar a saída.</p>
<ul>
<li><p>Para usar strings literais formatadas</span></a>, comece uma string com <code class="docutils literal notranslate"><span class="pre">f</span></code> ou <code class="docutils literal notranslate"><span class="pre">F</span></code>, antes de abrir as aspas ou aspas triplas. Dentro dessa string, pode-se escrever uma expressão Python entre caracteres <code class="docutils literal notranslate"><span class="pre">{</span></code> e <code class="docutils literal notranslate"><span class="pre">}</span></code>, que podem se referir a variáveis, ou valores literais.</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">year</span> <span class="o">=</span> <span class="mi">2016</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">event</span> <span class="o">=</span> <span class="s1">'Referendum'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">f</span><span class="s1">'Results of the </span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">event</span><span class="si">}</span><span class="s1">'</span>
<span class="go">'Results of the 2016 Referendum'</span>
</pre></div>
</div>
</li>
<li><p>O método de strings str.format() requer mais esforço manual. Ainda será necessário usar <code class="docutils literal notranslate"><span class="pre">{</span></code> e <code class="docutils literal notranslate"><span class="pre">}</span></code> para marcar onde a variável será substituída e pode-se incluir diretivas de formatação detalhadas, mas também precisará incluir a informação a ser formatada.</p><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">yes_votes</span> <span class="o">=</span> <span class="mi">42_572_654</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">no_votes</span> <span class="o">=</span> <span class="mi">43_132_495</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">percentage</span> <span class="o">=</span> <span class="n">yes_votes</span> <span class="o">/</span> <span class="p">(</span><span class="n">yes_votes</span> <span class="o">+</span> <span class="n">no_votes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'</span><span class="si">{:-9}</span><span class="s1"> YES votes  </span><span class="si">{:2.2%}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">yes_votes</span><span class="p">,</span> <span class="n">percentage</span><span class="p">)</span>
<span class="go">' 42572654 YES votes  49.67%'</span>
</pre></div>
</div>
</li>
<li><p>Finalmente, pode-se fazer todo o tratamento da saída usando as operações de fatiamento e concatenação de strings para criar qualquer layout que se possa imaginar. O tipo string possui alguns métodos que realizam operações úteis para preenchimento de strings para uma determinada largura de coluna.</p></li>
</ul>
<p>Quando não é necessário sofisticar a saída, mas apenas exibir algumas variáveis com propósito de depuração, pode-se converter qualquer valor para uma string com as funções repr() ou str().</p>
<p>A função str() serve para retornar representações de valores que sejam legíveis para as pessoas, enquanto repr() é para gerar representações que o interpretador Python consegue ler (ou levantará uma exceção SyntaxError, se não houver sintaxe equivalente). Para objetos que não têm uma representação adequada para consumo humano, str() devolve o mesmo valor que repr(). Muitos valores, tal como números ou estruturas, como listas e dicionários, têm a mesma representação usando quaisquer das funções. Strings, em particular, têm duas representações distintas.</p>
<p>Alguns exemplos:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">'Hello, world.'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">'Hello, world.'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">"'Hello, world.'"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">)</span>
<span class="go">'0.14285714285714285'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mf">3.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mi">200</span> <span class="o">*</span> <span class="mi">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">'The value of x is '</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s1">', and y is '</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="s1">'...'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">The value of x is 32.5, and y is 40000...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The repr() of a string adds string quotes and backslashes:</span>
<span class="gp">... </span><span class="n">hello</span> <span class="o">=</span> <span class="s1">'hello, world</span><span class="se">\n</span><span class="s1">'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hellos</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hellos</span><span class="p">)</span>
<span class="go">'hello, world\n'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The argument to repr() may be any Python object:</span>
<span class="gp">... </span><span class="nb">repr</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="s1">'spam'</span><span class="p">,</span> <span class="s1">'eggs'</span><span class="p">)))</span>
<span class="go">"(32.5, 40000, ('spam', 'eggs'))"</span>
</pre></div>
</div>
<p>O módulo string contém uma classe Template que oferece ainda outra maneira de substituir valores em strings, usando espaços reservados como <code class="docutils literal notranslate"><span class="pre">$x</span></code> e substituindo-os por valores de um dicionário, mas oferece muito menos controle da formatação.</p>
<section id="formatted-string-literals">
<span id="tut-f-strings"></span><h3><span class="section-number">7.1.1. </span>Strings literais formatadas</h3>
<p>Strings literais formatadas (também chamadas f-strings, para abreviar) permite que se inclua o valor de expressões Python dentro de uma string, prefixando-a com <code class="docutils literal notranslate"><span class="pre">f</span></code> ou <code class="docutils literal notranslate"><span class="pre">F</span></code> e escrevendo expressões na forma <code class="docutils literal notranslate"><span class="pre">{expression}</span></code>.</p>
<p>Um especificador opcional de formato pode ser incluído após a expressão. Isso permite maior controle sobre como o valor é formatado. O exemplo a seguir arredonda pi para três casas decimais:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'The value of pi is approximately </span><span class="si">{</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>
<span class="go">The value of pi is approximately 3.142.</span>
</pre></div>
</div>
<p>Passando um inteiro após o <code class="docutils literal notranslate"><span class="pre">':'</span></code> fará com que o campo tenha um número mínimo de caracteres de largura. Isso é útil para alinhar colunas.</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'Sjoerd'</span><span class="p">:</span> <span class="mi">4127</span><span class="p">,</span> <span class="s1">'Jack'</span><span class="p">:</span> <span class="mi">4098</span><span class="p">,</span> <span class="s1">'Dcab'</span><span class="p">:</span> <span class="mi">7678</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">phone</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s1">10</span><span class="si">}</span><span class="s1"> ==&gt; </span><span class="si">{</span><span class="n">phone</span><span class="si">:</span><span class="s1">10d</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Sjoerd     ==&gt;       4127</span>
<span class="go">Jack       ==&gt;       4098</span>
<span class="go">Dcab       ==&gt;       7678</span>
</pre></div>
</div>
<p>Outros modificadores podem ser usados para converter o valor antes de ser formatado. <code class="docutils literal notranslate"><span class="pre">'!a'</span></code> aplica a função ascii(), <code class="docutils literal notranslate"><span class="pre">'!s'</span></code> aplica a função str() e <code class="docutils literal notranslate"><span class="pre">'!r'</span></code> aplica a função repr()</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">animals</span> <span class="o">=</span> <span class="s1">'eels'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'My hovercraft is full of </span><span class="si">{</span><span class="n">animals</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>
<span class="go">My hovercraft is full of eels.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'My hovercraft is full of </span><span class="si">{</span><span class="n">animals</span><span class="si">!r}</span><span class="s1">.'</span><span class="p">)</span>
<span class="go">My hovercraft is full of 'eels'.</span>
</pre></div>
</div>
<p>O especificador <code class="docutils literal notranslate"><span class="pre">=</span></code> pode ser usado para expandir uma expressão para o texto da expressão, um sinal de igual e, então, a representação da expressão avaliada:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bugs</span> <span class="o">=</span> <span class="s1">'roaches'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="mi">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area</span> <span class="o">=</span> <span class="s1">'living room'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Debugging </span><span class="si">{</span><span class="n">bugs</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">count</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">area</span><span class="si">=}</span><span class="s1">'</span><span class="p">)</span>
<span class="go">Debugging bugs='roaches' count=13 area='living room'</span>
</pre></div>
</div>
<p>Veja expressões autodocumentadas para mais informações sobre o especificador <code class="docutils literal notranslate"><span class="pre">=</span></code>. Para obter uma referência sobre essas especificações de formato, consulte o guia de referência para a Minilinguagem de especificação de formato.</p>
</section>
<section id="the-string-format-method">
<span id="tut-string-format"></span><h3><span class="section-number">7.1.2. </span>O método format()</h3>
<p>Um uso básico do método str.format() tem esta forma:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'We are the </span><span class="si">{}</span><span class="s1"> who say "</span><span class="si">{}</span><span class="s1">!"'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'knights'</span><span class="p">,</span> <span class="s1">'Ni'</span><span class="p">))</span>
<span class="go">We are the knights who say "Ni!"</span>
</pre></div>
</div>
<p>As chaves e seus conteúdos (chamados campos de formatação) são substituídos pelos objetos passados para o método str.format(). Um número nas chaves pode ser usado para referenciar a posição do objeto passado no método str.format().</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="si">{0}</span><span class="s1"> and </span><span class="si">{1}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">,</span> <span class="s1">'eggs'</span><span class="p">))</span>
<span class="go">spam and eggs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="si">{1}</span><span class="s1"> and </span><span class="si">{0}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">,</span> <span class="s1">'eggs'</span><span class="p">))</span>
<span class="go">eggs and spam</span>
</pre></div>
</div>
<p>Se argumentos nomeados são passados para o método str.format(), seus valores serão referenciados usando o nome do argumento:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'This </span><span class="si">{food}</span><span class="s1"> is </span><span class="si">{adjective}</span><span class="s1">.'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="gp">... </span>      <span class="n">food</span><span class="o">=</span><span class="s1">'spam'</span><span class="p">,</span> <span class="n">adjective</span><span class="o">=</span><span class="s1">'absolutely horrible'</span><span class="p">))</span>
<span class="go">This spam is absolutely horrible.</span>
</pre></div>
</div>
<p>Argumentos posicionais e nomeados podem ser combinados à vontade:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'The story of </span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">, and </span><span class="si">{other}</span><span class="s1">.'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'Bill'</span><span class="p">,</span> <span class="s1">'Manfred'</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">other</span><span class="o">=</span><span class="s1">'Georg'</span><span class="p">))</span>
<span class="go">The story of Bill, Manfred, and Georg.</span>
</pre></div>
</div>
<p>Se uma string de formatação é muito longa, e não se deseja quebrá-la, pode ser bom fazer referência aos valores a serem formatados por nome, em vez de posição. Isto pode ser feito passando um dicionário usando colchetes <code class="docutils literal notranslate"><span class="pre">'[]'</span></code> para acessar as chaves.</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'Sjoerd'</span><span class="p">:</span> <span class="mi">4127</span><span class="p">,</span> <span class="s1">'Jack'</span><span class="p">:</span> <span class="mi">4098</span><span class="p">,</span> <span class="s1">'Dcab'</span><span class="p">:</span> <span class="mi">8637678</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'Jack: </span><span class="si">{0[Jack]:d}</span><span class="s1">; Sjoerd: </span><span class="si">{0[Sjoerd]:d}</span><span class="s1">; '</span>
<span class="gp">... </span>      <span class="s1">'Dcab: </span><span class="si">{0[Dcab]:d}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table</span><span class="p">))</span>
<span class="go">Jack: 4098; Sjoerd: 4127; Dcab: 8637678</span>
</pre></div>
</div>
<p>Isto também pode ser feito passando o dicionário <code class="docutils literal notranslate"><span class="pre">table</span></code> como argumentos nomeados com a notação <code class="docutils literal notranslate"><span class="pre">**</span></code>.</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'Sjoerd'</span><span class="p">:</span> <span class="mi">4127</span><span class="p">,</span> <span class="s1">'Jack'</span><span class="p">:</span> <span class="mi">4098</span><span class="p">,</span> <span class="s1">'Dcab'</span><span class="p">:</span> <span class="mi">8637678</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'Jack: </span><span class="si">{Jack:d}</span><span class="s1">; Sjoerd: </span><span class="si">{Sjoerd:d}</span><span class="s1">; Dcab: </span><span class="si">{Dcab:d}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">table</span><span class="p">))</span>
<span class="go">Jack: 4098; Sjoerd: 4127; Dcab: 8637678</span>
</pre></div>
</div>
<p>Isto é particularmente útil em conjunto com a função embutida vars(), que devolve um dicionário contendo todas as variáveis locais.</p>
<p>Como exemplo, as linhas seguintes produzem um conjunto de colunas alinhadas, com alguns inteiros e seus quadrados e cubos:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="si">{0:2d}</span><span class="s1"> </span><span class="si">{1:3d}</span><span class="s1"> </span><span class="si">{2:4d}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go"> 1   1    1</span>
<span class="go"> 2   4    8</span>
<span class="go"> 3   9   27</span>
<span class="go"> 4  16   64</span>
<span class="go"> 5  25  125</span>
<span class="go"> 6  36  216</span>
<span class="go"> 7  49  343</span>
<span class="go"> 8  64  512</span>
<span class="go"> 9  81  729</span>
<span class="go">10 100 1000</span>
</pre></div>
</div>
<p>Para uma visão completa da formatação de strings com str.format(), veja a seção Sintaxe das strings de formato.</p>
</section>
<section id="manual-string-formatting">
<h3><span class="section-number">7.1.3. </span>Formatação manual de string</h3>
<p>Aqui está a mesma tabela de quadrados e cubos, formatados manualmente:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">' '</span><span class="p">)</span>
<span class="gp">... </span>    <span class="c1"># Note use of 'end' on previous line</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go"> 1   1    1</span>
<span class="go"> 2   4    8</span>
<span class="go"> 3   9   27</span>
<span class="go"> 4  16   64</span>
<span class="go"> 5  25  125</span>
<span class="go"> 6  36  216</span>
<span class="go"> 7  49  343</span>
<span class="go"> 8  64  512</span>
<span class="go"> 9  81  729</span>
<span class="go">10 100 1000</span>
</pre></div>
</div>
<p>(Note que o espaço entre cada coluna foi adicionado pela forma que a função print() funciona: sempre adiciona espaços entre seus argumentos.)</p>
<p>O método str.rjust() justifica uma string à direita, num campo de tamanho definido, acrescentando espaços à esquerda. De forma similar, os métodos str.ljust(), justifica à esquerda, e str.center()</span></code></a>, para centralizar. Esses métodos não escrevem nada, apenas retornam uma nova string. Se a string de entrada é muito longa, os métodos não truncarão a saída, e retornarão a mesma string, sem mudança; isso vai atrapalhar o layout da coluna, mas geralmente é melhor do que a alternativa, que estaria distorcendo o valor. (Se realmente quiser truncar, sempre se pode adicionar uma operação de fatiamento, como em <code class="docutils literal notranslate"><span class="pre">x.ljust(n)[:n]</span></code>.)</p>
<p>Existe ainda o método >str.zfill() que preenche uma string numérica com zeros à esquerda, e sabe lidar com sinais positivos e negativos:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'12'</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">'00012'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'-3.14'</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">'-003.14'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'3.14159265359'</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">'3.14159265359'</span>
</pre></div>
</div>
</section>
<section id="old-string-formatting">
<h3><span class="section-number">7.1.4. </span>Formatação de strings à moda antiga</h3>
<p>O operador % (módulo) também pode ser usado para formatação de string. Dado <code class="docutils literal notranslate"><span class="pre">'string'</span> <span class="pre">%</span> <span class="pre">valores</span></code>, as instâncias de <code class="docutils literal notranslate"><span class="pre">%</span></code> em <code class="docutils literal notranslate"><span class="pre">string</span></code> são substituídas por zero ou mais elementos de <code class="docutils literal notranslate"><span class="pre">valores</span></code>. Essa operação é conhecida como interpolação de string. Por exemplo:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'The value of pi is approximately </span><span class="si">%5.3f</span><span class="s1">.'</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">The value of pi is approximately 3.142.</span>
</pre></div>
</div>
<p>Mais informação pode ser encontrada na seção Formatação de String no Formato no estilo printf.</p>
</section>
</section>
<section id="reading-and-writing-files">
<span id="tut-files"></span><h2><span class="section-number">7.2. </span>Leitura e escrita de arquivos</h2>
<p id="index-0">open()</a> retorna um objeto arquivo, e é mais utilizado com dois argumentos posicionais e um argumento nomeado: <code class="docutils literal notranslate"><span class="pre">open(filename,</span> <span class="pre">mode,</span> <span class="pre">encoding=None)</span></code></p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'workfile'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">"utf-8"</span><span class="p">)</span>
</pre></div>
</div>
<p>O primeiro argumento é uma string contendo o nome do arquivo. O segundo argumento é outra string, contendo alguns caracteres que descrevem o modo como o arquivo será usado. <em>modo</em> pode ser <code class="docutils literal notranslate"><span class="pre">'r'</span></code> quando o arquivo será apenas lido, <code class="docutils literal notranslate"><span class="pre">'w'</span></code> para escrever (se o arquivo já existir seu conteúdo prévio será apagado), e <code class="docutils literal notranslate"><span class="pre">'a'</span></code> para abrir o arquivo para adição; qualquer escrita será adicionada ao final do arquivo. A opção <code class="docutils literal notranslate"><span class="pre">'r+'</span></code> abre o arquivo tanto para leitura como para escrita. O argumento <em>modo</em> é opcional, em caso de omissão será assumido <code class="docutils literal notranslate"><span class="pre">'r'</span></code>.</p>
<p>Normalmente, arquivos são abertos no <em class="dfn">modo texto</em>, o que significa que você lê strings de e para o arquivo, o qual está em um codificação específica. Se a <em>codificação</em> não for especificada, o padrão irá depender da plataforma (veja open()). Como o UTF-8 é o padrão mais moderno, <code class="docutils literal notranslate"><span class="pre">encoding="utf-8"</span></code> é recomendado a não ser que você precise utilizar uma <em>codificação</em> diferente. Adicionando <code class="docutils literal notranslate"><span class="pre">'b'</span></code> ao modo irá abrir o o arquivo em <em class="dfn">modo binário</em>. Dados no modo binário são lidos e escritos como objetos bytes.  Você não pode especificar a <em>codificação</em> quando estiver abrindo os arquivos em modo binário.</p>
<p>Em modo texto, o padrão durante a leitura é converter terminadores de linha específicos da plataforma (<code class="docutils literal notranslate"><span class="pre">\n</span></code> no Unix, <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> no Windows) para apenas <code class="docutils literal notranslate"><span class="pre">\n</span></code>. Ao escrever no modo de texto, o padrão é converter as ocorrências de <code class="docutils literal notranslate"><span class="pre">\n</span></code> de volta para os finais de linha específicos da plataforma. Essa modificação de bastidores nos dados do arquivo é adequada para arquivos de texto, mas corromperá dados binários, como arquivos <code class="file docutils literal notranslate"><span class="pre">JPEG</span></code> ou <code class="file docutils literal notranslate"><span class="pre">EXE</span></code>. Tenha muito cuidado para só usar o modo binário, ao ler e gravar esses arquivos.</p>
<p>É uma boa prática usar a palavra-chave with ao lidar com arquivos. A vantagem é que o arquivo é fechado corretamente após o término de sua utilização, mesmo que uma exceção seja levantada em algum momento. Usar <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> também é muito mais curto que escrever seu bloco equivalente tryfinally:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'workfile'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">"utf-8"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">read_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We can check that the file has been automatically closed.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">closed</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Se você não está usando a palavra reservada with, então você deveria chamar <code class="docutils literal notranslate"><span class="pre">f.close()</span></code> para fechar o arquivo e imediatamente liberar qualquer recurso do sistema usado por ele.</p>
<div class="admonition warning">
<p class="admonition-title">Aviso</p>
<p>Chamar <code class="docutils literal notranslate"><span class="pre">f.write()</span></code> sem usar a palavra reservada <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> ou chamar <code class="docutils literal notranslate"><span class="pre">f.close()</span></code> <strong>pode</strong> resultar nos argumentos de <code class="docutils literal notranslate"><span class="pre">f.write()</span></code> não serem completamente escritos no disco, mesmo se o programa for encerrado com êxito.</p>
</div>
<p>Depois que um arquivo é fechado, seja por uma instrução with ou chamando <code class="docutils literal notranslate"><span class="pre">f.close()</span></code>, as tentativas de usar o arquivo falharão automaticamente.</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span><span>
  File </span><span class="nb">"&lt;stdin&gt;"</span><span>, line </span><span class="m">1</span><span>, in </span><span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span><span>: </span><span class="n">I/O operation on closed file.</span>
</pre></div>
</div>
<section id="methods-of-file-objects">
<span id="tut-filemethods"></span><h3><span class="section-number">7.2.1. </span>Métodos de objetos arquivo</h3>
<p>Para simplificar, o resto dos exemplos nesta seção assumem que um objeto arquivo chamado <code class="docutils literal notranslate"><span class="pre">f</span></code> já foi criado.</p>
<p>Para ler o conteúdo de um arquivo, chame <code class="docutils literal notranslate"><span class="pre">f.read(tamanho)</span></code>, que lê um punhado de dados devolvendo-os como uma string (em modo texto) ou bytes (em modo binário). <em>tamanho</em> é um argumento numérico opcional. Quando <em>tamanho</em> é omitido ou negativo, todo o conteúdo do arquivo é lido e devolvido; se o arquivo é duas vezes maior que memória da máquina, o problema é seu. Caso contrário, no máximo <em>tamanho</em> caracteres (em modo texto) ou <em>tamanho</em> bytes (em modo binário) são lidos e devolvidos. Se o fim do arquivo for atingido, <code class="docutils literal notranslate"><span class="pre">f.read()</span></code> devolve uma string vazia (<code class="docutils literal notranslate"><span class="pre">''</span></code>).</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">'This is the entire file.\n'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">''</span>
</pre></div>
</div>
<p>O método <code class="docutils literal notranslate"><span class="pre">f.readline()</span></code> lê uma única linha do arquivo; o caractere de quebra de linha (<code class="docutils literal notranslate"><span class="pre">\n</span></code>) é mantido ao final da string, e só é omitido na última linha do arquivo, se o arquivo não terminar com uma quebra de linha. Isso elimina a ambiguidade do valor retornado; se <code class="docutils literal notranslate"><span class="pre">f.readline()</span></code> retorna uma string vazia, o fim do arquivo foi atingido. Linhas em branco são representadas por um <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> – uma string contendo apenas o caractere terminador de linha.</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">'This is the first line of the file.\n'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">'Second line of the file\n'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">''</span>
</pre></div>
</div>
<p>Uma maneira alternativa de ler linhas do arquivo é iterar diretamente pelo objeto arquivo. É eficiente, rápido e resulta em código mais simples:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">This is the first line of the file.</span>
<span class="go">Second line of the file</span>
</pre></div>
</div>
<p>Se desejar ler todas as linhas de um arquivo em uma lista, pode-se usar <code class="docutils literal notranslate"><span class="pre">list(f)</span></code> ou <code class="docutils literal notranslate"><span class="pre">f.readlines()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">f.write(string)</span></code> escreve o conteúdo de <em>string</em> para o arquivo, retornando o número de caracteres escritos.</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'This is a test</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
<p>Outros tipos de objetos precisam ser convertidos – seja para uma string (em modo texto) ou para bytes (em modo binário) – antes de escrevê-los:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'the answer'</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># convert the tuple to string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">18</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">f.tell()</span></code> retorna um inteiro dando a posição atual do objeto arquivo, no arquivo representado, como número de bytes desde o início do arquivo, no modo binário, e um número ininteligível, quando no modo de texto.</p>
<p>Para mudar a posição, use <code class="docutils literal notranslate"><span class="pre">f.seek(offset,</span> <span class="pre">de_onde)</span></code>. A nova posição é computada pela soma do deslocamento <em>offset</em> a um ponto de referência especificado pelo argumento <em>de-onde</em>. Se o valor de <em>de_onde</em> é 0,a referência é o início do arquivo, 1 refere-se à posição atual, e 2 refere-se ao fim do arquivo. Este argumento pode ser omitido e o valor padrão é 0, usando o início do arquivo como referência.</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'workfile'</span><span class="p">,</span> <span class="s1">'rb+'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">'0123456789abcdef'</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>      <span class="c1"># Go to the 6th byte in the file</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">b'5'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Go to the 3rd byte before the end</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">b'd'</span>
</pre></div>
</div>
<p>Em arquivos texto (abertos sem um <code class="docutils literal notranslate"><span class="pre">b</span></code>, em modo string), somente <em>seeks</em> relativos ao início do arquivo serão permitidos (exceto se for indicado o final do arquivo, com <code class="docutils literal notranslate"><span class="pre">seek(0,</span> <span class="pre">2)</span></code>) e o único valor válido para <em>offset</em> são aqueles retornados por chamada à <code class="docutils literal notranslate"><span class="pre">f.tell()</span></code>, ou zero. Qualquer outro valor para <em>offset</em> produz um comportamento indefinido.</p>
<p>Objetos arquivo tem alguns método adicionais, como <code class="xref py py-meth docutils literal notranslate"><span class="pre">isatty()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">truncate()</span></code> que não são usados com frequência; consulte a Biblioteca de Referência para um guia completo de objetos arquivo.</p>
</section>
<section id="saving-structured-data-with-json">
<span id="tut-json"></span><h3><span class="section-number">7.2.2. </span>Gravando dados estruturados com json</h3>
<p id="index-1">Strings podem ser facilmente gravadas e lidas em um arquivo. Números dão um pouco mais de trabalho, já que o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> só retorna strings, que terão que ser passadas para uma função como int(), que pega uma string como <code class="docutils literal notranslate"><span class="pre">'123'</span></code> e retorna seu valor numérico 123. Quando você deseja salvar tipos de dados mais complexos, como listas e dicionários aninhados, a análise e serialização manual tornam-se complicadas.</p>
<p>Ao invés de ter usuários constantemente escrevendo e depurando código para gravar tipos complicados de dados em arquivos, o Python permite que se use o popular formato de troca de dados chamado JSON (JavaScript Object Notation). O módulo padrão chamado json pode pegar hierarquias de dados em Python e convertê-las em representações de strings; esse processo é chamado <em class="dfn">serialização</em>. Reconstruir os dados estruturados da representação string é chamado <em class="dfn">desserialização</em>. Entre serializar e desserializar, a string que representa o objeto pode ser armazenada em um arquivo, ou estrutura de dados, ou enviada por uma conexão de rede para alguma outra máquina.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>O formato JSON é comumente usado por aplicativos modernos para permitir troca de dados. Pessoas que programam já estão familiarizadas com esse formato, o que o torna uma boa opção para interoperabilidade.</p>
</div>
<p>Um objeto <code class="docutils literal notranslate"><span class="pre">x</span></code>, pode ser visualizado na sua representação JSON com uma simples linha de código:</p>
<pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'simple'</span><span class="p">,</span> <span class="s1">'list'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">'[1, "simple", "list"]'</span>
</pre></div>
</div>
<p>Outra variação da função dumps(), chamada dump(), serializa o objeto para um arquivo texto. Se <code class="docutils literal notranslate"><span class="pre">f</span></code> é um arquivo texto aberto para escrita, podemos fazer isto:</p>
<div class="highlight-python3 notranslate" style="position: relative;"><div class="highlight"><pre><span></span><span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Para decodificar o objeto novamente, se <code class="docutils literal notranslate"><span class="pre">f</span></code> é um objeto arquivo binário ou arquivo texto que foi aberto para leitura:</p>
<div class="highlight-python3 notranslate" style="position: relative;"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Arquivos JSON devem ser codificados em UTF-8. Use <code class="docutils literal notranslate"><span class="pre">encoding="utf-8"</span></code> quando abrir um arquivo JSON como um arquivo texto tanto para leitura quanto para escrita.</p>
</div>
<p>Essa técnica de serialização simples pode manipular listas e dicionários, mas a serialização de instâncias de classes arbitrárias no JSON requer um pouco mais de esforço. A referência para o módulo json contém uma explicação disso.</p>
<p>Ao contrário do JSON, <em>pickle</em> é um protocolo que permite a serialização de objetos Python arbitrariamente complexos. Por isso, é específico do Python e não pode ser usado para se comunicar com aplicativos escritos em outros linguagens. Também é inseguro por padrão: desserializar dados de pickle, provenientes de uma fonte não confiável, pode executar código arbitrário, se os dados foram criados por um invasor habilidoso.</p>
</div>
</section>
</section>
</section>

  <body background="./img/Banner.png"></body>
</body>
</html>